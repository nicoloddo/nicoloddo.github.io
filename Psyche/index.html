<!DOCTYPE html>
<html lang="en-us">
  <head>
    <script>
      const API_KEY = '$2b$10$INYNLzgjp4rl9cJhxbTc8ugvQNlgZbAu2HX8cXK647NJmn945I3h.';
      const API_URL = 'https://api.jsonbin.io/v3/b';
      const headers = {
          'Content-Type': 'application/json',
          'X-Access-Key': API_KEY
      };

      let updateQueue = [];
      // Function to process the functions calls in order
      async function processUpdateQueue() {
          if (updateQueue.length > 0) {
              const update = updateQueue[0];
              const result = await updateUserBin(update.binId, update.data);
              updateQueue.shift();
              processUpdateQueue();
          }
      }

      // Function to create a new BIN for a user
      async function createNewBinForUser(userData) {
        const response = await fetch(API_URL, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(userData)
        });

        const result = await response.json();
        localStorage.setItem('userBinId', result.metadata.id);
        console.log("Stored userBinId: ", localStorage.getItem('userBinId'));
        console.log("New BIN created with ID: ", result.metadata.id);
        return result.record;
      }

      // Function to get a user's BIN
      async function getUserBin(binId) {
        const response = await fetch(`${API_URL}/${binId}`, {
            method: 'GET',
            headers: headers
        });
        return await response.json();
      }

      // Function to update a user's BIN with new data
      async function updateUserBin(binId, newData) {
        // First, retrieve the current data from the bin
        const currentData = await getUserBin(binId);

        // Append the new data to the existing data
        // Assuming currentData.record.LiveData is an array
        currentData.record.LiveData.push(newData);

        // Now, send the updated (combined) data back to the server
        const response = await fetch(`${API_URL}/${binId}`, {
            method: 'PUT',
            headers: headers,
            body: JSON.stringify(currentData.record)
        });

        const result = await response.json();
        console.log("Updated BIN with ID: ", binId);
        return result.record;
      }
      
      // On page load, create a new BIN for new users
      window.addEventListener('load', (event) => {
          console.log("Page loaded. Checking for userBinId...");
          
          const userBinId = localStorage.getItem('userBinId');
          console.log("Retrieved userBinId: ", userBinId);

          if (!userBinId || userBinId === 'null' || userBinId === 'undefined') {
              console.log("No userBinId found. Creating new bin for user...");
              
              const initialData = {LiveData: [
              { 
                time: new Date().toISOString(),
                action: 'New user created', 
              }]};
              createNewBinForUser(initialData);
          }
      });

      window.AIterminated = async function() {
        const binId = localStorage.getItem('userBinId');
        const data = {
            time: new Date().toISOString(),
            action: "AIterminated",
        };
    
        updateQueue.push({binId: binId, data: data});
        processUpdateQueue();
      }

      window.AIcontinue = async function() {
        const binId = localStorage.getItem('userBinId');
        const data = {
            time: new Date().toISOString(),
            action: "AIcontinue",
        };
    
        updateQueue.push({binId: binId, data: data});
        processUpdateQueue();
      }

      window.ChoiceTimeStarted = async function() {
        const binId = localStorage.getItem('userBinId');
        const data = {
            time: new Date().toISOString(),
            action: "ChoiceTimeStarted",
        };
    
        updateQueue.push({binId: binId, data: data});
        processUpdateQueue();
      }

      window.ChoiceTimeExpired = async function() {
        const binId = localStorage.getItem('userBinId');
        const data = {
            time: new Date().toISOString(),
            action: "ChoiceTimeExpired",
        };
    
        updateQueue.push({binId: binId, data: data});
        processUpdateQueue();
      }

      window.Win = async function() {
        const binId = localStorage.getItem('userBinId');
        const data = {
            time: new Date().toISOString(),
            action: "Win",
        };
    
        updateQueue.push({binId: binId, data: data});
        processUpdateQueue();
      }

      window.GameOver = async function() {
        const binId = localStorage.getItem('userBinId');
        const data = {
            time: new Date().toISOString(),
            action: "GameOver",
        };
    
        updateQueue.push({binId: binId, data: data});
        processUpdateQueue();
      }

      window.NextLevel = async function() {
        const binId = localStorage.getItem('userBinId');
        const data = {
            time: new Date().toISOString(),
            action: "NextLevel",
        };
    
        updateQueue.push({binId: binId, data: data});
        processUpdateQueue();
      }

      window.Restart = async function() {
        const binId = localStorage.getItem('userBinId');
        const data = {
            time: new Date().toISOString(),
            action: "Restart",
        };
    
        updateQueue.push({binId: binId, data: data});
        processUpdateQueue();
      }

      window.FinalData = async function(jsonData) {
        console.log("Received from Unity:", jsonData);
        var data = JSON.parse(jsonData);

        const binId = localStorage.getItem('userBinId');
        // First, retrieve the current data from the bin
        const currentData = await getUserBin(binId);
        
        // Add the new data as a field named 'Data' on the same level as 'LiveData'
        // 'newData' is assigned to 'currentData.record.Data'
        // Check if 'record.Data' already exists
        if (currentData.record.Data) {
            // If 'record.Data' already exists, merge 'data' into it
            currentData.record.Data.Level2 = data.Level2;
            currentData.record.Data.FormInfo = data.FormInfo;
        } else {
            // If 'record.Data' does not exist, create it and set it to 'data'
            currentData.record.Data = data;
        }

        // Now, send the updated (combined) data back to the server
        const response = await fetch(`${API_URL}/${binId}`, {
            method: 'PUT',
            headers: headers,
            body: JSON.stringify(currentData.record)
        });

        const result = await response.json();
        console.log("Finalized BIN with ID: ", binId);
        return result.record;
      }      

    </script>



    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Psyche</title>
    <link rel="icon" type="image/png" href="../Logos/icon.png">
    <style>
      body, html {
        height: 100%;
        margin: 0;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #231F20;
      }
      #unity-canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <canvas id="unity-canvas"></canvas>
    <script src="../JS/pleaserotate.min.js"></script>
    <script src="Build/Psyche.loader.js"></script>
    <script>
      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        var meta = document.createElement('meta');
        meta.name = 'viewport';
        meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        document.getElementsByTagName('head')[0].appendChild(meta);
      }

      createUnityInstance(document.querySelector("#unity-canvas"), {
        dataUrl: "Build/Psyche.data",
        frameworkUrl: "Build/Psyche.framework.js",
        codeUrl: "Build/Psyche.wasm",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "nicoloddo",
        productName: "Psyche",
        productVersion: "7.0",
        //matchWebGLToCanvasSize: true, // Adjust to make WebGL canvas size match the size of its DOM element.
      });

    </script>
  </body>
</html>

